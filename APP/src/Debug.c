/**********************************************************************************************************************
 * \file Debug.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "Incl.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define DBG_PORT_OMR_REG(p)           (*(vu32 *)((u32)&MODULE_P00 + (0x1000*(u32)(p/10))+(0x0100*(p%10))+4))

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/
static s16 s_sFirmVer = 0;
#ifdef TC234_KIT_BOARD
static const DbgPortCfg_t s_xrgucDbgPortGrp[] =
{

    { 33, 0 },
    { 33, 1 },
    { 33, 2 },
    { 33, 3 },
    { 33, 8 },
    { 33, 9 },
    { 33, 10 },
    { 33, 11 },

};
#endif
#ifdef _APP_KIT_BOARD_
static const DbgPortCfg_t s_xrgucDbgPortGrp[] =
{

    { 13, 0 },
    { 13, 1 },
    { 13, 2 },
    { 13, 3 },
};
#endif
static CandyDescr_t s_xCandyDescr = { 0 };
static int s_giCmdTipCnt = 1;
static uint8_t s_grgucTab1024[1024] = { 0 };

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
static void prvTempFunction(void) { vDbgPrintf("\r\nPlease, input 0 ~ %d number to select a command.\r\n", s_giCmdTipCnt-1); }
static void prvResetDevice(void);
static void prvTestAT25E2promFunction(void);
static void prvTestTBootFunction(void);
static void prvDownloadImage(void);
static struct
{
    void (* xpFunc)(void);
    char *psstrTip;
} s_xCmdTip[] =
{
    { prvTempFunction, "Please, input number to select a command." },
    { prvResetDevice, "Reset computer." },
    { prvTestAT25E2promFunction, "Test AT25128 EEPROM.\r\n   (Send random data at random address, and compare these with the memory)" },
    { prvTestTBootFunction, "Test t-boot jump.\r\n   (Test TSmart Bootloader)" },
    { prvDownloadImage, "Download image to the device internal flash.\r\n   (Transfer: Receive Ymodem)" },
    { 0, 0 }
};
static void prvPrintCmdMenu(void);
static void prvProcCmdKey(uint8 ucKey);
static int prvGetIntNum_GJ(uint8_t ucByte);
static void prvUpdateVerInfo(char *pcVer);
static BaseType_t prvWaitForKeyInput(void);
/* The task that is created three times. */
static portTASK_FUNCTION_PROTO(vDebugTask, pvParameters);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
static void prvResetDevice( void )
{
    vDbgPrintf("                    ()()\r\n");
    vDbgPrintf("[GoodByte Computer] (.. )\r\n\n");

    Mcal_ResetSafetyENDINIT_Timed(150000U);
    /* Enable the SMU system reset request */
    SCU_RSTCON.B.SMU = 0x1;

    while (1);
}
/*-----------------------------------------------------------*/

static void prvTestAT25E2promFunction(void)
{
    #ifdef TC234_KIT_BOARD
    {
        uint8_t ucValTemp;
        uint8_t ucVal;
        BaseType_t xAddr;

        xAddr = ((xTaskGetTickCount() + rand())&0x3FFF);
        ucValTemp = (uint8_t)((xTaskGetTickCount()+rand())&0xFF);

        vAT25WriteE2Prom(xAddr, ucValTemp);
        ucVal = ucAT25ReadE2Prom(xAddr);
        vDbgPrintf("\r\n[EEPROM] Data[ 0x%02X ], Address %04Xh . . . %s\r\n", ucValTemp, xAddr, (ucValTemp == ucVal ? "OK" : "NG"));
    }
    #else
    {
        vDbgPrintf("\r\nEEPROM is not available\r\n");
    }
    #endif
}
/*-----------------------------------------------------------*/

void (*__run)(void) = (void(*)(void))(debAPPLICATION_PFLS_ADDR);
static void prvTestTBootFunction(void)
{
    volatile Ifx_SRC *SRCs = &MODULE_SRC;
    __disable();

    SRCs->STM.STM[0].SR0.B.SRE = 0;
    __run();
    while (1);
}
/*-----------------------------------------------------------*/

static void prvDownloadImage(void)
{ 
    BaseType_t xSize = 0;
    register int i;

    vDbgPrintf("\r\n\nWaiting for the file to be sent ... (press 'a' to abort)\r\n");
    xSize = xYmodemReceive(&s_grgucTab1024[0]);

    while (get_ch() != -1);

    for (i=0; i<0xF00000; i++);

    if (xSize>=0) {
        vDbgPrintf("\n\n\rProgramming Completed Successfully!\r\n");
#if 0     
        vDbgPrintf("--------------------------------\r\n Name: ");
        uint8_t rgucNumber[12] = "          ";
        vDbgPrintf((char *)pYmodemGetFileName());
        Int2Str(rgucNumber, (int) xSize);
        vDbgPrintf("\r\n Size: ");
        vDbgPrintf(( char * ) rgucNumber);
        vDbgPrintf(" Bytes\r\n");
        vDbgPrintf("--------------------------------\r\n");
#endif        
    }
    else if (xSize==-1) {
        vDbgPrintf("\n\n\rThe image size is higher than the allowed space memory!\n\r");
    }
    else if (xSize==-2) {
        vDbgPrintf("\n\n\rVerification failed!\n\r");
    }
    else if (xSize==-3) {
        vDbgPrintf("\r\n\nAborted by user.\n\r");
    }
    else {
        vDbgPrintf("\n\rFailed to receive the file! %u\n\r", xSize);
    }
}
/*-----------------------------------------------------------*/

static void prvPrintCmdMenu(void)
{
    vDbgPrintf("\r\n----------------------------------------------------------------------------------");
    vDbgPrintf("\r\nPlease, select a function : \r\n");
    vDbgPrintf("? : Display this menu\r\n");

    for (s_giCmdTipCnt=0; s_xCmdTip[s_giCmdTipCnt].xpFunc!=0; s_giCmdTipCnt++) {
        vDbgPrintf("%d : %s\r\n", s_giCmdTipCnt, s_xCmdTip[s_giCmdTipCnt].psstrTip);
    }
    vDbgPrintf("----------------------------------------------------------------------------------\r\n");

    vDbgPrintf("\r\n");
}
/*-----------------------------------------------------------*/

static void prvProcCmdKey(uint8 ucKey)
{
    int iIdx;

    if (ucKey != '?') {
        iIdx = prvGetIntNum_GJ((uint8_t)ucKey);

        if (iIdx < s_giCmdTipCnt) {
            (*s_xCmdTip[iIdx].xpFunc)();
        }
        else {
            vDbgPrintf("Please, be sure your selected number %d\r\n", iIdx);
        }
    }

    prvPrintCmdMenu();
}
/*-----------------------------------------------------------*/

static int prvGetIntNum_GJ(uint8_t ucByte)
{
    int iData = 0;

    if ((ucByte<'0') || (ucByte>'9')) {
        return 0;
    }

    iData = ucByte - '0';

    return iData;
}
/*-----------------------------------------------------------*/

static void prvUpdateVerInfo(char *pcVer)
{
    char rgcTmp[32];
    char *pc;
    int iSize;
    int i;

    vDbgPrintf("\r\nSmartRT v%s, Kernel "tskKERNEL_VERSION_NUMBER" Start\r\n", pcVer);
    vDbgPrintf(""__TIME__", "__DATE__" TSmart Alpha Project Team (c)2022 \r\n\n\n");

    iSize = strlen(pcVer);
    pc = rgcTmp;

    for(i=0; i<iSize; i++, pcVer++) {
        if ((*pcVer>='0')&&(*pcVer<='9'))
            *pc++ = *pcVer;
    }

    *pc = '\0';

    s_sFirmVer = (s16)strtoul(rgcTmp, 0, 10);
}
/*-----------------------------------------------------------*/

static BaseType_t prvWaitForKeyInput(void)
{
    BaseType_t xKey;
    TickType_t xTick0;
    int iPrintSec = 0;

    xTick0 = xTaskGetTickCount();
    vDbgPrintf("Wait Key - (0)");
    vDbgPortToggle(0);

    for (;;){
        if ((xKey = get_ch()) != -1) {
            vDbgPortSet(0);
            vDbgPortSet(1);
            vDbgPortSet(2);

            if ((xKey == 'a') || (xKey == 'A')) {
                vDbgPrintf("\r\nOK - Release Key\r\n\n");
                return 0;
            }
            else {
                vDbgPrintf("\r\n\n");
                return -1;
            }
        }
        else {
            if (_absdiff_ulong(xTick0, xTaskGetTickCount())>CLKSecondsToTicks(3L)) {
                if (iPrintSec == 2) {
                    iPrintSec++;
                    vDbgPrintf("\x08\x08\x08(%d)\r\n\n", iPrintSec);
                    vDbgPortToggle(2);
                    break;
                }
            }
            else if (_absdiff_ulong(xTick0, xTaskGetTickCount()) > CLKSecondsToTicks(2L)) {
                if (iPrintSec == 1) {
                    iPrintSec++;
                    vDbgPrintf("\x08\x08\x08(%d)", iPrintSec);
                    vDbgPortToggle(1);
                    vDbgPortToggle(2);
                }
            }
            else if (_absdiff_ulong(xTick0, xTaskGetTickCount()) > CLKSecondsToTicks(1L)) {
                if (iPrintSec == 0) {
                    iPrintSec++;
                    vDbgPrintf("\x08\x08\x08(%d)", iPrintSec);
                    vDbgPortToggle(0);
                    vDbgPortToggle(1);
                }
            }
        }
    }

    return -2;
}
/*-----------------------------------------------------------*/

void vStartDebugTask(char *pcVer)
{
    register int i;
    prvUpdateVerInfo(pcVer);

    #if defined(TC234_KIT_BOARD) || defined(_APP_KIT_BOARD_)
    {
        for (i=0; i<(int)(sizeof(s_xrgucDbgPortGrp)/sizeof(DbgPortCfg_t)); i++)
            vDbgPortSet((u32)i);
    }
    #endif

    for (i=0; i<candyRCVD_BUFF_NUM; i++)
        s_xCandyDescr.rgxRcvd[i].xUsed = pdFALSE;


    xTaskCreate(vDebugTask, "DEBUG", configDEBUG_TASK_STACK_DEPTH, NULL, configDEBUG_TASK_PRIORITY, NULL);
}
/*-----------------------------------------------------------*/

void vDbgPrintf(char *pecFmt, ...)
{
    char xPrintBuffWr[128];
    signed long lReturn = 0;
    BaseType_t xTimeout = 0xFFFFF;

    va_list xMarker;

    va_start(xMarker, pecFmt);
    lReturn = (signed long)vsnprintf(xPrintBuffWr, 128, pecFmt, xMarker);
    if (lReturn<0)
        lReturn = 128;     // max. length reached

    xPrintBuffWr[lReturn] = '\0';
    va_end(xMarker);

    Uart_Write(0, (Uart_MemPtrType)xPrintBuffWr, (Uart_SizeType)lReturn);
    while ((Uart_GetStatus(0) == UART_BUSY) && xTimeout--);
}
/*-----------------------------------------------------------*/

void vDbgPortSet(u32 xIndex)
{
    #if defined(TC234_KIT_BOARD) || defined(_APP_KIT_BOARD_)
    {
        if (xIndex < (u32)(sizeof(s_xrgucDbgPortGrp)/sizeof(DbgPortCfg_t)))
            DBG_PORT_OMR_REG(s_xrgucDbgPortGrp[xIndex].xPort) = (1<<s_xrgucDbgPortGrp[xIndex].xIndex);
    }
    #endif
}
/*-----------------------------------------------------------*/

void vDbgPortReset(u32 xIndex)
{
    #if defined(TC234_KIT_BOARD) || defined(_APP_KIT_BOARD_)
    {
        if (xIndex < (u32)(sizeof(s_xrgucDbgPortGrp)/sizeof(DbgPortCfg_t)))
            DBG_PORT_OMR_REG(s_xrgucDbgPortGrp[xIndex].xPort) = (2<<(s_xrgucDbgPortGrp[xIndex].xIndex + 15));
    }
    #endif
}
/*-----------------------------------------------------------*/

void vDbgPortToggle(u32 xIndex)
{
    #if defined(TC234_KIT_BOARD) || defined(_APP_KIT_BOARD_)
    {
        if (xIndex < (u32)(sizeof(s_xrgucDbgPortGrp)/sizeof(DbgPortCfg_t)))
            DBG_PORT_OMR_REG(s_xrgucDbgPortGrp[xIndex].xPort) = ((2<<(s_xrgucDbgPortGrp[xIndex].xIndex + 15))|(1<<s_xrgucDbgPortGrp[xIndex].xIndex));
    }
    #endif
}
/*-----------------------------------------------------------*/

boolean CanLpduReceiveNotification(uint8 Hrh, Can_IdType CanId, uint8 CanDlc, const uint8 *CanSduPtr)
{
    return 1;
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION(vDebugTask, pvParameters)
{
    TickType_t xLastWakeTime;
    TickType_t xAliveT0;
    BaseType_t xWasDelayed;
    BaseType_t xKey;
    UBaseType_t xRet;

    if (prvWaitForKeyInput() < 0)
    {
        vTaskDelay(CLKMilliSecsToTicks(3));
        prvTestTBootFunction();
    }

    xRet = FlsLoader_Init(NULL_PTR);
    vDbgPrintf("-I- Flash Init Execution Result: %d\r\n\n", xRet);

    /* Forever empty loop - All activity executed in periodic interrupts on each core */
    xAliveT0 = xTaskGetTickCount();
    xLastWakeTime = xAliveT0;

    Can_17_MCanP_SetControllerMode(Can_17_MCanPConf_CanController_CanController_0, CAN_T_START);

    prvPrintCmdMenu();

    for (;;)
    {
        if ((xKey = get_ch(/*VOID*/)) != -1) {
            prvProcCmdKey((uint8)xKey);
        }
        else {
            if (_absdiff_ulong(xAliveT0, xTaskGetTickCount()) > CLKMilliSecsToTicks(1000)) {
                xAliveT0 = xTaskGetTickCount();
                vDbgPortToggle(0);
            }

            xWasDelayed = xTaskDelayUntil(&xLastWakeTime, CLKMilliSecsToTicks(1));
        }
    }

    UNUSED_PARAMETER(pvParameters);
    UNUSED_PARAMETER(xWasDelayed);
}
/*-----------------------------------------------------------*/
